import os
import argparse
import sys
from glob import glob
from utilities import *
import vtk
import numpy as np
from vtk.util.numpy_support import vtk_to_numpy, numpy_to_vtk

class ProjectToNewMesh():
	def __init__(self,Args):
		self.Args=Args
		if self.Args.OutputFolder is None:
			self.Args.OutputFolder=self.Args.InputFolder.replace(self.Args.InputFolder.split("/")[-1],self.Args.InputFolder.split("/")[-1]+"_coarse/")
			os.system("mkdir %s"%self.Args.OutputFolder)

		else:
			os.system("mkdir %s/"%self.Args.OutputFolder)
			self.Args.OutputFolder=self.Args.OutputFolder+"/"

	def Main(self):
		#Read all of the file name
		InputFiles=sorted(glob(self.Args.InputFolder+"/all_results.vtu*.vtu")) #volumetric files 
		print ("--- Total number of Files: %d"%len(InputFiles))
		InputFiles=InputFiles[::self.Args.Skip]
			
		#Read the Coarse Mesh
		MeshVolume=ReadVTUFile(self.Args.InputFileName)
		print ("--- Read the Mesh File: %s"%self.Args.InputFileName)

		#Extract the Surface Mesh from Coarse Mesh
		print ("--- Extracting a Surface Mesh")
		MeshSurface=vtk.vtkDataSetSurfaceFilter()
		MeshSurface.PassThroughPointIdsOn() #creates a new point array = "vtkOriginalPointIds"
		MeshSurface.SetInputData(MeshVolume)
		MeshSurface.Update()
		MeshSurface=MeshSurface.GetOutput()
		
	
		#Read the first input file and get the number of arrays
		InputFile1=ReadVTUFile(InputFiles[0])
		NArrays=InputFile1.GetPointData().GetNumberOfArrays()
		ArrayNames=[InputFile1.GetPointData().GetArrayName(i) for i in range(NArrays)]

		#Extracting Surface Mesh for Velocity File
		VelocitySurface=vtk.vtkDataSetSurfaceFilter()
		VelocitySurface.PassThroughPointIdsOn() 
		VelocitySurface.SetInputData(InputFile1)
		VelocitySurface.Update()
		VelocitySurface=VelocitySurface.GetOutput()
		WriteVTPFile("VelocitySurface.vtp",VelocitySurface)
		exit(1)


		#Get the IDs in the Velocity File that correspond to the Mesh File only for the wall
		print ("--- Extracting the Closest Points only for the Surface Mesh")
		ClosestPointIds=[]
		PointLocator_=vtk.vtkPointLocator()
		PointLocator_.SetDataSet(VelocitySurface)
		PointLocator_.BuildLocator()
		for i in range(MeshSurface.GetNumberOfPoints()):
			Id_=PointLocator_.FindClosestPoint(MeshSurface.GetPoint(i))
			ClosestPointIds.append(VelocitySurface.GetPointData().GetArray("vtkOriginalPointIds").GetValue(Id_))

		#Create a Probe Filter
		ProbeFilter_=vtk.vtkProbeFilter()
		ProbeFilter_.SetInputData(MeshVolume)
	
		#Loop over all of the time series
		for InputFileName_ in InputFiles:
			print ("------ Projecting File: %s"%InputFileName_)
			InputFile_=ReadVTUFile(InputFileName_)
			ProbeFilter_.SetSourceData(InputFile_)
			ProbeFilter_.Update()
			Data_=ProbeFilter_.GetOutput()

			#Now project the closest value onto the wall for all the arraynames
			for i in range(MeshSurface.GetNumberOfPoints()): #Loop over all of the wall ids
				Id_=MeshSurface.GetPointData().GetArray("vtkOriginalPointIds").GetValue(i)
				for ArrayName_ in ArrayNames:
					Value_=InputFile_.GetPointData().GetArray(ArrayName_).GetValue(ClosestPointIds[i])
					Data_.GetPointData().GetArray(ArrayName_).SetValue(Id_,0)#Value_)
					
			#Write the Output File
			WriteVTUFile(self.Args.OutputFolder+InputFileName_.split("/")[-1],Data_)
	
if __name__=="__main__":
        #Arguments
	parser= argparse.ArgumentParser(description="This script will project results generated by simvascular onto a coarser mesh.")

	parser.add_argument('-InputFolder', '--InputFolder', type=str, required=True, dest="InputFolder", help="The input folder that contains all of the results file, taged ass all_results.vtu.XXXXX.vtu")	
	
	parser.add_argument('-InputFileName', '--InputFileName', type=str, required=True, dest="InputFileName", help="The input file corresponds to the mesh onto which the results will be projected.")	
	
	parser.add_argument('-Skip', '--Skip', type=int, required=False, default=1, dest="Skip", help="Skip factor to reduce the number of time series data (e.g., skip=2 means only every other file will be used)")	

	parser.add_argument('-OutputFolder', '--OutputFolder', type=str, required=False, dest="OutputFolder", help="The output folder to store the time-averaged file in.")
	
	#Put all the arguments together
	args=parser.parse_args()

        #Call your Class
	ProjectToNewMesh(args).Main()	
